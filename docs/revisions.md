


<details> <summary> man 7 gitrevision & translated by DeepL! </summary>


GITREVISIONS(7) Git 매뉴얼 GITREVISIONS(7)

NAME
       gitrevisions - Git의 리비전과 범위 지정하기

SYNOPSIS
       gitrevisions

설명
       많은 Git 명령은 리비전 매개변수를 인수로 사용합니다. 명령에 따라
       명령에 따라 특정 커밋을 나타내거나, 리비전 그래프를 따라가는 명령의 경우
       리비전 그래프(예: git-log(1))에서 해당 커밋에 도달할 수 있는 모든 커밋을
       도달할 수 있는 모든 커밋을 나타낸다. 리비전 그래프를 따라가는 명령의 경우
       의 경우 리비전 범위를 명시적으로 지정할 수도 있다.

       또한 일부 Git 명령(예: git-show(1) 및 git-push(1))
       는 커밋 이외의 다른 개체를 나타내는 리비전 매개변수를 받을 수도 있다.
       블롭("파일") 또는 트리("파일 디렉터리")와 같은 다른 개체를 나타내는 리비전 매개변수를 사용할 수도 있다.

리비전 지정하기
       리비전 매개변수 `rev`는 일반적으로, 그러나 반드시 그런 것은 아니지만, 커밋 오브젝트의 이름을 지정한다.
       커밋 오브젝트를 지정한다. 이 매개변수는 확장 SHA-1 구문을 사용한다. 여기
       는 오브젝트 이름의 철자를 지정하는 다양한 방법이다. 이 목록의 맨 끝에 나열된
       에 나열된 것은 커밋에 포함된 트리와 블롭의 이름이다.

           참고

           이 문서는 git에서 보는 "원시" 구문을 보여준다. 셸과
           다른 UI는 특수 문자"를 보호하고 단어 분할을 피하기 위해 추가 인용이 필요할 수 있다.
           문자를 보호하고 단어 분할을 방지하기 위해 추가 인용이 필요할 수 있다.

       `sha1`, 예: dae86e1950b1277e545cee180551750029cfe735, dae86e
           전체 SHA-1 개체 이름(40바이트 16진수 문자열) 또는
           리포지토리 내에서 고유한 선행 하위 문자열. 예
           dae86e1950b1277e545cee180551750029cfe735와 dae86e는 모두 같은 커밋 오브젝트의
           리포지토리에 다른 오브젝트가 없는 경우 동일한 커밋 오브젝트의 이름을 지정합니다.
           오브젝트 이름이 dae86e로 시작하는 경우.

       `describeOutput`, 예: v1.7.4.2-679-g3bee7fb
           git describe의 출력, 즉 가장 가까운 태그, 선택적으로 대시 뒤에
           대시와 커밋 수, 그 뒤에 대시, g, 그리고
           축약된 오브젝트 이름.

       `refname`, 예: master, heads/master, refs/heads/master
           기호 참조 이름. 예: 마스터는 일반적으로 refs/heads가 참조하는 커밋 오브젝트를 의미하며
           커밋 오브젝트를 의미합니다. 만약 둘 다 가지고 있다면
           모두 가지고 있다면, 명시적으로 heads/master
           라고 명시적으로 말해서 어느 것을 의미하는지 Git에 알릴 수 있다. 모호한 경우, `참조 이름`은
           다음 규칙에서 가장 먼저 일치하는 것을 사용하여 모호성을 제거합니다:

            1. GIT_DIR/`refname`이 존재하면, 그 파일을 의미한다(이 규칙은
               일반적으로 HEAD, FETCH_HEAD, ORIG_HEAD, MERGE_HEAD
               및 CHERRY_PICK_HEAD에만 유용합니다);

            2. 그렇지 않으면, refs/`refname`이 존재하면;

            3. 그렇지 않으면, refs/tags/`refname`이 존재하면;

            4. 그렇지 않으면, refs/heads/`refname`이 존재하면;

            5. 그렇지 않으면, refs/remotes/`refname`이 있으면;

            6. 그렇지 않으면, refs/remotes/`refname`/HEAD가 있으면.

               HEAD는 작업 트리에서 변경의 기준이 되는 커밋의 이름을 지정한다.
               커밋의 이름을 지정합니다.  FETCH_HEAD는 원격 리포지토리에서 가져온 브랜치를
               원격 리포지토리에서 가져온 브랜치를 기록합니다.
               ORIG_HEAD는 HEAD를 급격하게 이동하는 명령에 의해 생성됩니다.
               과감하게 이동하는 명령(git am, git merge, git rebase, git reset)에 의해 생성됩니다.
               작업하기 전에 HEAD의 위치를 기록하여
               브랜치 끝을 실행하기 전의 상태로 쉽게
               상태로 쉽게 변경할 수 있다.  MERGE_HEAD는 브랜치에 병합하는 커밋을 기록한다.
               브랜치에 병합하는 커밋을 기록한다.
               CHERRY_PICK_HEAD는 커밋을 실행할 때 체리 피킹하는 커밋을
               체리-픽하는 커밋을 기록한다.

               위의 ref/* 케이스는 다음 중 하나에서 올 수 있습니다.
               GIT_DIR/refs 디렉터리 또는 $GIT_DIR/packed-refs
               파일에서 올 수 있습니다. ref 이름 인코딩은 지정되지 않았지만, 일부 출력 처리에서 인코딩이 변경될 수 있으므로
               일부 출력 처리는 참조 이름을
               UTF-8.

       @
           단독으로 HEAD에 대한 단축키입니다.

       [`refname`]@{`date`}(예: master@{yesterday}, HEAD@{5분 전})
           참조 뒤에 접미사 @를 붙이고 날짜 사양을 중괄호로 묶어
           중괄호 쌍(예: {yesterday}, {1개월 2주 3일 1시간
           1초 전} 또는 {1979-02-26 18:30:00})은 이전 시점에 대한
           ref의 값을 지정합니다. 이 접미사는 참조 이름 및 참조 바로 뒤에만 사용할 수 있습니다.
           바로 뒤에만 사용할 수 있으며 참조에는 기존의
           로그($GIT_DIR/logs/`ref`)가 있어야 한다. 이 명령은 주어진 시점의
           상태(예: 지난주에 로컬 마스터
           브랜치에 무엇이 있었는지. 특정 시간 동안 커밋된 커밋을 보고 싶다면
           특정 시간 동안 만들어진 커밋을 보려면 --since 및 --until을 참조하세요.

       `refname`@{`n`}, 예: 마스터@{1}
           ref 뒤에 접미사 @와 함께 서수 지정이 있는 경우
           (예: {1}, {15})로 둘러싸인 참조는 해당 참조의 n번째 이전
           값을 지정합니다. 예를 들어 master@{1}은 마스터의 바로 이전 값이며
           값이고 master@{5}는 마스터의 5번째 이전 값입니다.
           이 접미사는 참조 이름 바로 뒤에만 사용할 수 있으며
           참조에는 기존 로그가 있어야 한다($GIT_DIR/logs/`refname`).

       @{`n`}, 예: @{1}
           빈 ref 부분과 함께 @ 구문을 사용하여 현재 브랜치의
           리로그 항목을 가져올 수 있습니다. 예를 들어
           브랜치에 있다면 @{1}은 blabla@{1}과 같은 의미입니다.

       @{-`n`}, 예: @{-1}
           구조체 @{-`n`}은 현재 브랜치보다 `n`번째로 체크아웃된 브랜치/커밋을 의미한다.
           를 의미한다.

       [`브랜치명`]@{업스트림}, 예: master@{업스트림}, @{u}
           브랜치 B는 브랜치 X 위에 빌드되도록 설정할 수 있다(
           브랜치.`이름`.merge로 구성) 원격 R에서 브랜치 X(브랜치
           원격 R에서 가져온 X, 일반적으로 refs/remotes/R/X에서 찾을 수 있음).

       [`브랜치명`]@{push}, 예: master@{push}, @{push}
           접미사 @{push}는 다음과 같은 경우 "푸시할 브랜치"를 알려준다.
           브랜치 이름이 체크 아웃되는 동안 git push가 실행되었다면 (또는 브랜치 이름이 지정되지 않은 경우 현재
           HEAD)를 알려준다(브랜치 이름이 지정되지 않은 경우). 업스트림의 경우 @{upstream}과 마찬가지로
           해당 브랜치에 해당하는 원격 추적 브랜치
           를 보고합니다.

           다음은 더 명확하게 설명하기 위해 M-^@M-^Y를 예로 든 것이다:

               $ git config push.default current
               $ git config remote.pushdefault myfork
               $ git switch -c mybranch origin/master

               $ git rev-parse --symbolic-full-name @{업스트림}
               refs/remotes/origin/master

               $ git rev-parse --symbolic-full-name @{push}
               refs/remotes/myfork/mybranch

           이 예제에서는 삼각형 워크플로우를 설정했는데, 한 위치에서 끌어오고 다른 위치로 푸시한다.
           한 위치에서 끌어오고 다른 위치로 푸시합니다. 삼각형이 아닌
           워크플로우에서 @{push}는 @{upstream}과 동일하며, @{push}가 필요하지 않습니다.
           가 필요하지 않습니다.

           이 접미사는 철자가 대문자로 되어 있을 때도 허용되며, 대소문자에 관계없이 같은 의미입니다.
           대소문자에 상관없이 같은 의미입니다.

       `rev`^[`n`], 예: HEAD^, v1.5.1^0
           리비전 매개변수에 접미사 ^는 해당 커밋 오브젝트의 첫 번째 부모를 의미한다.
           커밋 오브젝트의 첫 번째 부모를 의미한다.  ^`n`은 `n`번째 부모를 의미한다(즉, `rev`^는
           `rev`^1과 같다). 특별한 규칙으로, `rev`^0은 커밋 자체를 의미한다.
           자체를 의미하며, `rev`가 커밋 오브젝트를 가리키는 태그 오브젝트의 오브젝트 이름일 때
           의 오브젝트 이름일 때 사용한다.

       `rev`~[`n`], 예: HEAD~, 마스터~3
           리비전 매개변수에 접미사 ~는 해당 커밋 오브젝트의 첫 번째 부모를 의미한다.
           커밋 오브젝트의 첫 번째 부모를 의미한다. 리비전 매개변수에 접미사 ~`n`은 해당 커밋 오브젝트의
           라는 이름의 커밋 오브젝트의 `n`번째 세대 조상인
           커밋 오브젝트의 `n`번째 세대 조상인 커밋 오브젝트를 의미한다. 즉, `rev`~3은
           는 `rev`^^^에 해당하며, `rev`^1^1^1에 해당한다. 참조
           를 참조하세요.

       `rev`^{`유형`}, 예: v0.99.8^{commit}
           접미사 ^ 뒤에 중괄호 쌍으로 묶인 객체 유형 이름(
           은 `유형`의 객체를 찾을 때까지 재귀적으로 `rev`에서 객체를 참조 해제한다는 의미입니다.
           타입의 객체를 찾거나 객체를 더 이상 역참조할 수 없음을 의미합니다.
           (이 경우 바프). 예를 들어, `rev`가
           커밋인 경우, `rev`^{commit}은 해당 커밋에 해당하는 커밋
           객체를 설명합니다. 마찬가지로, `rev`가 트리인 경우, `rev`^{tree}는 해당 트리 오브젝트에 대해
           해당 트리 오브젝트를 설명한다.  `rev`^0은 다음과 같은 약어입니다.
           `rev`^{커밋}의 줄임말입니다.

           `rev`^{object}는 `rev`가 존재하는 객체의 이름을 지정하는 데 사용할 수 있습니다.
           존재하며, `rev`가 태그가 될 필요 없이, 그리고
           태그가 이미 객체이기 때문에 `rev`를 재참조할 필요가 없습니다.
           객체에 도달하기 위해 한 번도 참조를 해제할 필요가 없습니다.

           `rev`^{tag}를 사용하여 `rev`가 기존 태그 객체를 식별하도록 할 수 있습니다.
           태그 객체를 식별합니다.

       `rev`^{}, 예: v0.99.8^{}
           접미사 ^ 뒤에 빈 중괄호 쌍이 오는 것은 해당 객체가 태그일 수 있음을 의미합니다.
           태그일 수 있으며, 태그가 아닌 객체가 발견될 때까지 재귀적으로 태그를 참조 해제합니다.
           객체를 찾을 때까지 재귀적으로 태그를 참조합니다.

       `rev`^{/`텍스트`}(예: HEAD^{/불쾌한 버그 수정})
           리비전 매개변수에 접미사 ^를 붙이고 그 뒤에 중괄호 쌍을 붙입니다.
           가 슬래시로 시작하는 텍스트를 포함하면 아래의 :/fix nasty bug
           구문과 같지만, 가장 최근에 일치하는 커밋을 반환한다는 점을 제외하면
           를 반환한다는 점을 제외하면 말이다.

       :/`텍스트`, 예: :/fix nasty bug
           콜론과 슬래시, 텍스트가 뒤따르는 커밋의 이름은 지정한 정규식과 일치하는 커밋(
           커밋 메시지가 지정된 정규식과 일치하는 커밋을 지정한다. 이
           이름은 HEAD를 포함한 모든 레퍼런스의
           에서 도달할 수 있는 가장 어린 커밋을 반환한다. 정규식은 커밋 메시지의 모든 부분과
           부분과 일치할 수 있습니다. 문자열로 시작하는 메시지를 일치시키려면
           예를 들어 :/^foo를 사용할 수 있다. 특수 시퀀스 :/! 는 일치하는 대상에 대한
           수정자를 위해 예약되어 있다. :/!-foo는 음수 일치를 수행한다,
           반면 :/!!foo는 리터럴 ! 문자와 그 뒤에 foo를 일치시킵니다. Any
           로 시작하는 다른 시퀀스는 현재 예약되어 있습니다. 주어진 텍스트에 따라
           주어진 텍스트에 따라, 셸 'M-^@M-^Ys 단어 분할 규칙에는
           추가 인용이 필요할 수 있습니다.

       `rev`:`경로`, 예: HEAD:README, master:./README
           접미사 : 뒤에 경로가 오면 주어진 블롭 또는 트리의 이름을 지정합니다.
           콜론 앞 부분으로 명명된 트리형 객체의 경로입니다. A
           또는 ../로 시작하는 경로는 현재 작업 중인 디렉터리의
           디렉터리에 상대적입니다. 지정된 경로는 현재 작업 트리의
           작업 트리'M-^@M-^Ys 루트 디렉터리로 변환됩니다. 이 옵션은 커밋 또는 트리의
           커밋 또는 트리의 블롭이나 트리를 작업 트리와 동일한 트리 구조로
           에서 블롭이나 트리를 지정할 때 가장 유용하다.

       :[`n`:]`경로`, 예: :0:README, :README
           콜론, 선택적으로 스테이지 번호(0~3), 경로 뒤에
           콜론 뒤에 경로가 오면 인덱스의 블롭 오브젝트에 주어진 경로에 있는
           인덱스의 블롭 오브젝트의 이름을 지정합니다. 누락된 스테이지 번호(및 그 뒤에 오는 콜론)는
           은 0단계 항목의 이름을 지정합니다. 병합하는 동안 1단계는 일반적인
           조상이고, 2단계는 대상 브랜치 'M-^@M-^Ys 버전(일반적으로
           현재 브랜치), 3단계는 병합되는 브랜치의 버전이다.
           브랜치의 버전이다.

       다음은 Jon Loeliger가 그린 그림이다. 커미트 노드 B와 C는 모두
       커밋 노드 A의 부모입니다. 부모 커밋은 왼쪽에서 오른쪽으로 정렬된다.

           G H I J
            \ / \ /
             D E F
              \ | / \
               \ | / |
                \|/ |
                 B C
                  \ /
                   \ /
                    A

           A = = A^0
           B = A^ = A^1 = A~1
           C = = A^2
           D = A^^ = A^1^1 = A~2
           E = B^2 = A^^2
           F = B^3 = A^^3
           G = A^^^ = A^1^1^1 = A~3
           H = D^2 = B^^2 = A^^^2 = A~2^2
           I = F^ = B^3^ = A^^3^
           J = F^2 = B^3^2 = A^^3^2

범위 지정하기
       git log와 같은 히스토리 트래버스 명령은 단일 커밋이 아닌
       커밋 집합에서 작동한다.

       이러한 명령의 경우, 이전 섹션에서 설명한 표기법을 사용하여 단일 리비전을 지정하면
       표기법을 사용하여 단일 리비전을 지정하면 주어진 커밋에서 도달할 수 있는 커밋 집합을
       커밋 집합을 의미한다.

       여러 리비전을 지정하면 주어진 커밋에서 도달할 수 있는 커밋 집합을 의미한다.
       커밋의 집합을 의미한다.

       커밋'M-^@M-^Y에 도달할 수 있는 집합은 커밋 자체와 그 커밋이 속한
       조상 체인에 있는 커밋이다.

       연결된 커밋 집합을 지정하는 몇 가지 표기법이 있다.
       ("리비전 범위"라고 함)를 지정하는 표기법은 아래와 같다.

   커밋 제외
       ^`rev`(캐럿) 표기법
           커밋에서 도달 가능한 커밋을 제외하려면 접두사 ^ 표기법(
           표기법을 사용한다. 예를 들어 ^r1 r2는 r2에서 도달할 수 있는 커밋은 포함하지만
           (즉, r1과 그 상위 브랜치)는 제외한다.

   점 범위 표기법
       .. (두 점) 범위 표기법
           r1 r2 집합 연산은 너무 자주 나타나기 때문에 이에 대한 속기(
           가 있을 정도입니다. 커밋 r1과 r2가 두 개 있을 때 ('커밋 지정하기'에 설명된
           구문에 따라 이름 지정됨)이 있는 경우, r1과 r2에서 도달할 수 있는
           r2에서 도달할 수 있는 커밋을 제외하고
           r1에서 ^r1 r2로 도달할 수 있는 커밋을 요청할 수 있으며 r1..r2로 작성할 수 있다.

       ... (점 3개) 대칭 차이 표기법
           이와 유사한 표기법 r1...r2는 r1과
           r2의 대칭 차이라고 하며 $(git merge-base --all r1 r2)가 아닌 r1 r2 --로 정의된다. It
           는 r1(왼쪽) 또는 r2(오른쪽) 중 하나에서 도달할 수 있는 커밋의 집합이다.
           (왼쪽) 또는 r2(오른쪽) 중 하나에서 도달할 수 있지만 둘 다에서 도달할 수는 없다.

       이 두 가지 약식 표기법에서는 한쪽 끝을 생략하고 기본값을
       기본값은 HEAD입니다. 예를 들어, origin.. 은 origin..HEAD의 약어입니다.
       의 줄임말이며 "오리진 브랜치에서 포크한 이후 무엇을 했나요?"라고 묻습니다.
       마찬가지로 ..origin은 HEAD..origin의 줄임말이며 "오리진 브랜치에서 포크된 후
       오리진에서 포크한 이후 무엇을 했나요?"라고 묻습니다. 참고로 .. 는
       HEAD...HEAD는 도달할 수 있는 빈 범위이며
       도달할 수 없는 빈 범위입니다.

       두 개의 서로 다른 범위를 취하도록 특별히 설계된 명령
       (예: 두 범위를 비교하기 위한 "git range-diff R1 R2")는 존재하지만, 이 명령은
       예외이다. 달리 명시되지 않는 한, 커밋 집합에서 작동하는 모든 "git" 명령은
       커밋 집합에서 작동하는 모든 "git" 명령은 단일 리비전 범위에서 작동한다. 다시 말해
       두 개의 "두 점 범위 표기법"을 나란히 쓰면 다음과 같이 된다.

           $ git log A..B C..D

       는 대부분의 명령에 대해 두 개의 리비전 범위를 지정하지 않는다. 대신
       연결된 단일 커밋 집합의 이름을 지정한다.
       
              히스토리에서는 다음과 같다:

           ---A---B---o---o---C---D

       A와 B는 C에서 도달할 수 있으므로, 이 두 점으로 지정된 수정본 범위는
       에 의해 지정된 수정 범위는 하나의 커밋 D이다.

   기타 `rev`^ 상위 속기 표기법
       병합 커밋에 특히 유용한 세 가지 다른 단축키가 있다,
       커밋과 부모 커밋으로 구성된 집합의 이름을 지정하는 데 특히 유용하다.

       r1^@ 표기법은 r1의 모든 부모를 의미한다.

       r1^! 표기법은 커밋 r1을 포함하지만 그 부모는 모두 제외한다.
       이 표기법은 그 자체로 단일 커밋 r1을 나타낸다.

       `rev`^-[`n`] 표기법은 `rev`를 포함하지만 `n`번째 부모는 제외한다.
       (즉, `rev`^`n`..`rev`의 약어)를 제외하며, 지정하지 않으면 `n` = 1이 된다.
       이것은 일반적으로 커밋을 병합할 때 유용하다.
       병합된 브랜치에 있는 모든 커밋을 가져오려면 `commit`^-을 전달하고
       병합 커밋 `커밋`(`커밋` 자체 포함).

       `rev`^`n`은 하나의 커밋 부모를 지정하는 것이지만, 이 세 가지 표기법은
       세 가지 표기법은 부모도 고려한다. 예를 들어 다음과 같이 말할 수 있다.
       HEAD^2^@라고 말할 수 있지만 HEAD^@^2라고 말할 수는 없다.

리비전 범위 요약
       `rev`
           `rev`에서 도달할 수 있는 커밋을 포함한다(즉, `rev`와 그
           조상).

       ^`rev`
           `rev`에서 도달할 수 있는 커밋을 제외한다(즉, `rev`와 그
           조상).

       `rev1`..`rev2`
           `rev2`에서 도달할 수 있는 커밋은 포함하되, `rev1`에서 도달할 수 있는 커밋은 제외한다.
           커밋을 포함하되 `rev1`에서 도달할 수 있는 커밋은 제외한다. `rev1` 또는 `rev2` 중 하나가
           생략하면 기본값은 HEAD가 된다.

       `rev1`...`rev2`
           `rev1` 또는 `rev2`에서 연결할 수 있는 커밋을 포함하지만
           둘 다에서 도달할 수 있는 커밋은 제외한다. `rev1` 또는
           `rev2`가 생략되면 기본값은 HEAD가 된다.

       `rev`^@, 예: HEAD^@
           접미사 ^ 뒤에 at 기호를 붙이는 것은 `rev`의 모든
           부모를 모두 나열하는 것과 같다(즉, 커밋 자체는 포함하지 않고
           부모에서 접근할 수 있는 모든 것을 포함한다).

       `rev`^!, 예: HEAD^!
           접미사 ^ 뒤에 느낌표를 붙이는 것은
           커밋 `rev`와 모든 부모 앞에 ^를 붙여 제외한다.
           (및 그 조상)를 제외합니다.

       `rev`^-`n`, 예: HEAD^-, HEAD^-2
           `rev`^`n`..`rev`와 같으며, `n`이 지정되지 않은 경우 1이 됩니다.

       다음은 위의 Loeliger 그림을 사용한 몇 가지 예시입니다,
       'M-^@M-^Ys' 표기법의 각 단계를 주의 깊게 확장 및 선택하면 다음과 같습니다.
       철자를 설명합니다:

              Args 확장된 인자 선택된 커밋
              D G H D
              D F G H I J D F
              ^G D H D
              ^D B E I J F B
              ^D B C E I J F B C
              C I J F C
              B..C = ^B C C
              B...C = B ^F C G H D E B C
              B^- = B^...B
                     = ^B^1 B E I J F B
              C^@ = C^1
                     = F I J F
              B^@ = B^1 B^2 B^3
                     = D E F D G H E F I J
              C^! = C ^C^@
                     = C ^C^1
                     = C ^F C
              B^! = B ^B^@
                     = B ^B^1 ^B^2 ^B^3
                     = B ^D ^E ^F B
              F^! D = F ^I ^J D G H D F

참조
       GIT-REV-PARSE(1)

GIT
       git(1) 제품군의 일부

Git 2.40.0 03/13/2023 GITREVISIONS(7)


</details>

# revision 이란?
 
- https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection
- https://stackoverflow.com/questions/11792538/what-is-the-difference-between-a-commit-and-a-revision-in-git
- 걍 특정 git object 를 나타내는 방법들을 칭하는것 같다.
-  sha1 Hash 로 모든걸 식별하면 어려우니까... 
- 근데 거기에 기능이 더 있으면 좋겠으니까... 
- `HEAD~3`, `main@{5 minutes ago}` `v0.1.0:README.md` 이런게 모두 revision 임
- 그리고, git source code 에선 develop^3 을 develop^^^ 로 변환해서 사용한다. 엌
```
G H I J
\ / \ /
 D   E    F
  \  |  /  \
   \ | /    |
	\|/     |
	 B      C
	   \   /
	    \ /
		 A

A = = A^0
B = A^ = A^1 = A~1
C = = A^2
D = A^^ = A^1^1 = A~2
E = B^2 = A^^2
F = B^3 = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2 = B^^2 = A^^^2 = A~2^2
I = F^ = B^3^ = A^^3^
J = F^2 = B^3^2 = A^^3^2
```
