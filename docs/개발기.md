# rlt Dev-Log

# 20230918

- Git 을 frontend - backend 로 분할
	- Frontend: CLI  로 subcommand, 파싱 후 필요한 작업을 적절한 포멧으로 만들어 backend request
		- user friendly 한 UI 제공
		- `햣 ㅁㅇㅇ .` 해도 작동하는 frontend? `git commut` 이런거 오타 수정 해주기?? 
		- DTO 는 backend 를 해봐야 감이 올듯 
		- subcommand 별 help 잘 알려주기
		- 설계
			- 파싱?  / 분류 / request? (가장 많이 바뀌는 부분 -------- Backend 와 소통하는 부분)
	- Backend: 받은 request 를 적절히 처리 후 file 에 write. (파일 기반이지만 DB 기반으로 바꿔치기 해도 작동하게 할 수 있지 않을까? 대박 완전 클린아키텍쳐)
		- 멀라... request 받는 곳 - 실제 데이터 저장 - 응답
		- verbose 모드 지원
		- git add 를 하면 어떤 일이 일어나는지 쉽게 알 수 있도록
		- 최소 단위의 operation 으로 쪼갤 수 있지 않을까? 머... 파일 하나 읽기 -> 인코딩하기 -> object 생성 -> .git/path/to/save 에 저장 이런식으로 ... 

- CLI - 일단 CLI 지만, UI 라고 생각할 수 있을듯. GUI APP 이 될 수 있고, WEB 이 될 수 있고 등등
	- sdk or lib 처럼 만들어서, Add, Commit 같은걸 객체로 사용할 수 있게. 
		- 흠... chacha 생각해보기 


---
- 설계
	- 흠... 몰라 git hash-object 부터 냅다 갈긴다

---
- sha 1 & sha 256 지원...? 일단 sha1 로 gogo 

너무 막막하니 TDD 해야겠지?? 테스트는 영원한 네비게이터

---
TDD 는 안했는데 뭔가 완성됐다.

blob 를 만들어보는 방식으로 git add 를 하면 벌어지는 일을 구현함


# 20230919
러스트 하... 먼가 조금씩 아쉽다.
cfg = configuration 
dyn = dynamic
등등 익숙하지 않은 줄임말이 넘 많다. WNOHANG <- 이게 나은듯;  그래도 awk 나 AVL 같은 것보단 직관적이다.  저거보다 안직관적일수 없긴 해

그리고 Unit test 를 같은 파일에 작성한다. 원래 세상이 그런가? 내가... 테스트를 JS 랑 C++ 밖에 안해본 사람이라 너무 불편한건가? Java 는 어떰? 걔네도 데코레이터로 하던데 -> 응 얘네도 다른파일에 해 

하... 공식문서에서 TDD 를 안내할정도면 나름 진심인거 같은데 쩝... 아 근데 nest test 작성할때 module resolve 하던거 생각하니까 갑자기 맘에 들어졌다. 굿굿인듯 ㅋㅋ 

ㄹ러스트 공식문서에 cli 툴 만들기가 있네? 도랏 ㅎ https://rust-cli.github.io/book/tutorial/cli-args.html

홀수날은 프론트 짝수날은 백엔드 하면 될듯 ㅋㅋ

rust-clap 쓰는데 어렵다 진심 러스트 아직도 1도 모르겠다

---

# 20230920
근데 날짜 왜쓰지? 걍 커밋이 날짜아님? blame 갈기면 될텐데

충격대박꿀팁) unix socket 은 git add 해도 반응이 없다. named pipe 도 안받는다ㅏ. 

# 20230921

내가 진짜 오늘 init 구현한다.

걍 .rlt 파일 만들고 그안에 몇개 넣으면 되는거 아님? 
git init 두번하면 어케함?
.git 파일중 몇개만 지우면 어캄?

# 20230922

Blob -> hash-object 로 변환중...

# 20230923

그렇다. `.git` 은 DB 이며 Backend 의 Storage 다. 나머지 파일은 다 client 다. 그러했던것이다. 댑악.

어... 흠... 클라가 git hash-object -w test-file 을 입력하면 서버는 파일시스템에서 test-file 을 찾아 읽고, hash 후 .git/object 에 저장을 한다. 이게 흠... 같은 FS 긴 한데 먼가 구분되지 않나? .git/ 같이 core 한 부분이 저장되는 곳 && Client 가 자신의 파일을 들고와서 요청을 날리는 곳... 일케..

파일의 이름만 들고 왔을때 그걸 앞단에서 파일을 읽은 뒤 core 로 넘겨주는게 나은가? 아님 core 부분에서 read / write 를 다해버려? 

일단 filename 만 받아서 처리한다 치면 아래와 같음. 근데... 만약 workspace 가 외부에 있다면? 어캄? client 가 파일 내용을 담아서 요청을 보낸다면? 

![[client-with-workspace-and-core]]
[Excalidraw](../Excalidraw/client-with-workspace-and-core.excalidraw)

여기서 workspace 가 plugin architecture 처럼... 되는건가? 아님 말고 ㅋㅋ


<details> <summary> 
ChatGPT 한테 물어봤따. GPT 는 신이다.
</summary>

Designing a remote-enabled `git hash-object` functionality can be a fun challenge. Let's break this down.

### Design Considerations:

1. **Separation of Concerns**: Keep the logic of hashing separate from the logic of obtaining the file content. Whether the content comes from a local filesystem or over the network should be abstracted away.

2. **Data Sources**: You'll essentially have three data sources:
    - Local filesystem
    - Direct file content passed in the request
    - Remote client's filesystem via an HTTP endpoint

3. **Consistency**: Regardless of the source of the file content, the hashing mechanism and return values should be consistent.

### Proposed Design:

1. **File Content Retrieval Interface**: Design an interface (in Rust, a trait) that abstracts away the source of the file content. This trait might look something like:

    ```rust
    trait FileContentProvider {
        fn get_content(&self, filename: &str) -> Result<Vec<u8>, SomeErrorType>;
    }
    ```

2. **Implementations of the Interface**:
    - `LocalFilesystemProvider`: Reads content from the local filesystem.
    - `DirectContentProvider`: Uses the file content passed directly in the request.
    - `RemoteClientProvider`: Retrieves content from a remote client's filesystem via HTTP.

3. **Hashing Logic**: Implement the hashing logic as a standalone function or a module that takes in file content (in the form of bytes) and returns the hash. This function/module should not care where the content comes from.

4. **Endpoint Logic**: If you're providing this functionality via an HTTP API:
    - Allow clients to either send the filename (in which case, you use the `RemoteClientProvider`) or send the file content directly (using `DirectContentProvider`).
    - Based on what the client sends, pick the right provider to fetch the content, then hash it, and return the hash.

5. **Command Line Logic**: For command-line use:
    - If given just a filename, use the `LocalFilesystemProvider`.
    - If there's a way to accept raw content (maybe from stdin or as a direct argument), use the `DirectContentProvider`.

### Sample Flow for HTTP API:

1. **Client Sends Filename**:
    - Client sends a request like `POST /hash-object` with a JSON body `{ "filename": "path/to/file/on/client" }`.
    - Your server uses the `RemoteClientProvider` to fetch the file content.
    - The content is then passed to the hashing function/module.
    - The hash is returned to the client.

2. **Client Sends Direct Content**:
    - Client sends a request like `POST /hash-object` with a JSON body `{ "content": "raw file content here..." }`.
    - Your server uses the `DirectContentProvider` to access the provided content.
    - The content is then passed to the hashing function/module.
    - The hash is returned to the client.

The main idea is to keep each component focused on one task. The hashing logic doesn't care about where the content comes from. The content providers don't care about what you do with the content once it's retrieved. This separation of concerns makes the design cleaner, more modular, and easier to extend or modify in the future.

 </details>

![[hash-object-from-gpt.excalidraw]]
[Excalidraw](../Excalidraw/hash-object-from-gpt.excalidraw)

- 각 Port 로 요청을 받으면 필요한 provider 를 생성하고 필요 시 잠시 저장해둔다. 
- Core 에선 WorkspaceProvider 로 추상화 된 인터페이스를 통해 접근한다. 
- 대박~

# 20230924

git cat-file 구현중...

object hash 도 받을 수 있고 branch 명도 받을 수 있는데 어캄?

이게 40자리 16진수인지 해서 isObject() 이런거?  흠... storage port 에서 해야하나? 근데 이거 core 아닌가? 흠... sha1 인지 sha256 인지도 판단해야하고 branch name 이나 HEAD 같은거면 refs 에서 읽어야 할 것 같은데? 

```
dest_filename = null
if not object 
	object_hash = read from refs
	dest_filename = "objects/" + object_hash[:2] + object_hash[2:]
else
	dest_filename = "objects/" + object_hash[:2] + object_hash[2:]
```

엄... 근데 HEAD~1 이딴건 어캄? 망 `git cat-file blob main:README.md` 이런것도 되는데?

main 을 commit 으로 읽기 -> 여기서 README.md 는 어케찾음? ㅋㅋ README.md 를 hash 해서 값 비교한다음.. 몰라? 

소스코드 보는데 쩝... 쉽지않다

- https://github.com/git/git/blob/master/git.c#L695
- https://github.com/git/git/blob/master/object-file.c